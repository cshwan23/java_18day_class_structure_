# java_18day_class_structure_
클래스 구조 문법/

객체의 메위주  .  속성변수 또는 메서드

 
x =aaa.bbb().ccc.xxx;

  .왼쪽(aaa)은 객체의 메위주(메서드를 가진 메위주)
  .오른쪽(bbb())은 속성변수나 메서드(메서드를 호출)
 
 .왼쪽(bbb())은 메위주가와야되는데 그 호출한 결과가 메위주. 리턴값은 클래스명일거다.
.오른쪽(ccc)은 속변(그 메위주의 속변)
 
.왼쪽(ccc)는 메위주 , 속변이자 메위주
.오른쪽 xxx는 속변.
 
=> . (점) 성분에 대한 분석

   private     Family    family ;

접근지정자    자료형      속성변수
                    클래스명   클래스의 메위주가 들어갈 예정(지금은 null)
 
 
overloading(오버로딩)

생성자를 하나더 만들겠다. public Sungjhk(){ }
똑같은 이름(메서드명/생성자명)을 두개 생성자를 만드는 것 => 오버로딩.(overloading)
생성자는 0개이상이여야 한다.
 
1. 생성자 overloading
같은 클래스 내부에 똑같은 이름의 생성자를 두개 이상 만드는 것.
 
<생성자 overloading이 성공하는 규칙>
생성자 이름 똑같이 만들어도 상관없지만
0. => 생성자 이름이 2개이상 같아야 함
1. => 매개변수의 갯수가 다르거나 
2. => 매개변수의 갯수가 똑같으면 매개변수의 자료형이 달라야한다.
=> 안그러면 에러가 난다.
 
2. 메서드 overloading
같은 클래스 내부에 똑같은 이름의 메서드를 두개 이상 만드는 것.
 
<메서드 overloading이 성공하는 규칙>
메서드 이름 또한 똑같이 만들 수 있다.
0. => 메소드 이름이 2개이상 같아야 함
1.  => 메서드의 매개변수의 갯수가 다르거나
2. =>매서드의 매개변수가 똑같으면 매개변수의 자료형이 다르면 만들 수 있다.
 
 
 
void( 매소드 앞에 void 가 붙으면?)
리턴할 데이터가 없다
public void setFamily(Family family) {

     this.family = family;

}

 
 
 
< 문 > 생성자 자동으로 생성되는 디폴트 생성자를 써라
=>   public 생성자명(클래스명) ( ) { }

복습 끝.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
2교시
 
메소드 
1, 기능 2. 리턴형(뭘 선물받는지) 3. 매개변수( 뭘 줘야하는지)
 
메소드명 앞 final
=> 메소드 오버라이딩 금지
 
메소드명 앞 abstract
=> 바디 없는 메소드가 하나이상 있다.
=> 자식이 와서 바디가 없는 걸 재정의해서 써라 (상속에 대한 열망)
 
<문1-1>
public static int xxx;
public int yyy;
 
public static void kkk() {
       xxx = 1;
       yyy = 1;     <-- 에러 터진다 
}
에러터지는 이유 : (static 이 붙은메소드안에서 동료를 호출하면 동료도 static이 붙어야한다)  
스태틱이 붙은메소드는 객체생성업시 호출가능한데 그메서드 안에 동료들도 스태틱이 붙어있어야 한다.
 
스태틱이 없으면 객체생성을 해야하는데.
 
 
 
<문1-2>(2교시 8-9분)
public static int xxx;
public int yyy;
 
public void kkk() {   // <--스태틱이 없으면
       xxx = 1;
       yyy = 1;     
}
에러안터진다 
이유 : 녹음. 
 
 
overriding / overloading

오버라이딩 / 오버로딩 
overloading(오버로딩)

=>생성자나 메서드를 똑같은 이름으로 생성.
 
 
overriding(오버라이딩)

=>부모가 클래스의 메서드이름을 그대로 자식에게 선언해서 가진것을
이름을 똑같이 가져오되 실행구문만 바꿔서 실행.(=재정의,영어로 overriding)
 
=> 매소드 오버라이딩 규칙
=> 1. 부모님이 같고있는 이름이 똑같아야됨
=> 2. 리턴형 똑같아야됨 
=> 3. 매개변수도 똑같아야됨.
=> 4. 접근지정자도 부모보다 같거나 커야됨 (무조건 public)
=> 5. 실행구문만 달라도 된다.
 
overriding / overloading  공통점 

똑같은 이름으로 만드는것
 
 
 
상속과 구현(인터페이스)의 차이점

상속

=> 부모걸 그대로 물려주는것
 
인터페이스

바디없는 메소드로만 구현되어있다.
부모걸 물려받는데 쓸수있는게 없어서 재창조 하는것.
아버지는 이름만 물려줌
아들은 이름을 가지고 재정의 해야함. 재정의가 아니라 재창조.
바디가 없기 때문에 새로만드는거나 다름없다.
새로만드는거나 다름없기 때문에상속이 아니라 구현
 
인터페이스는 리턴
객체의 메위주가 리턴되는게 맞는데 어떤객체가 될지 모른다.
후손이 누구인지 정확히 집을 수가 없다.
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
3교시
 
생성자

입사시험에서 제일 많이 틀리는 게 생성자
 
 
 
 
 
생성자 안에서 this(~) 용법

this() = > 동료생성자 호출하는 코딩
 
public class Xxx{
     int aaa;
     public Xxx() {
          this(3)
     }
     public Xxx(int bbb) {
          aaa = bbb;
     }
}
 
Xxx.x1 = new Wxx(5);
System.out.print( x1.aaa);
Xxx.x2 = new Xxx() ;
System.out.print( x2.aaa);
 
생성자 안에서 this () 가 호출되면 동료생성자를 호출한거다.
생성자끼리 호출이가능한 키워드가 this 다.
생성자끼리 호출이가능하다 필요에 의해서.
this( )는= 메소드 안에선 나올 수 없다.
생성자 안에서 동료생성자를 호출할때만 나온다.
 
 
 
생성자 안에서 super(~)용법

super.(~) => 부모생성자를 호출
 
public class A{
     int aaa;
 
     public A(int bbb) {
          aaa = bbb;
     }
     public void zzz( ) {
          aaa = 555;
     }
}
public class B extends A{
 
     public B( ) {
         super(4);  // super의 의미 부모의 생성자를 호출하라는 의미
     }
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡ
문제1 : 부모생성자중에 4를 받을 수 있는 놈이 있냐?
// Aclass 에서      
 
public A(int bbb) {
          aaa = bbb;
     }
가 있다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
문제2
public class B extends A{
 
//생성자안에는 부모
     public B( ) {
                         <--에러가 안터진다. (super.가 숨어있다/없으면 자바가 넣어준다.)
     }
}
 
// -> 부모생성자에 비어있는 생성자가 있어야 한다.
//자식 생성자안에는 부모생성자를 호출하는게 있어야한다.
없으면 자바가 super()를 넣어준다.
//자식생성자 안에 나오는 첫번째줄에 부모 생성자 호출하는 코딩이 첫줄에 나와야한다=>super()
//무조건 첫째줄에 나와야한다.
super this 공통점
둘다 생성자안에서만 나온다 메소드 안에서는 나오면 안된다.
 
super가 나오려면 부모가 있어야 한다.
자식이 일어나면 부모의 안부를 확인해야한다(=절대적인 효)
자식이 부모를 상속한다면 부모쪽의 호출을 가장 먼저 해야한다. 
안써도 들어간다 자동으로 super( ) <--부모생성자.
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
4교시
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
불행의 이유 = 게으름
하기싫은것도 처리를하면 인정을 받고 재밋어진다.
부지런하면 하게되고 인정을 받으면 재밌어진다 잘하게된다.
일자체가 재밌어진다 - 밤을새도재밌다
부지런함 => 어디까지 좋은점으로 이끄는지.
게으르니까 전문성있게 일을 안해. 외부에서보니 능력이 없어보이는것.
모든 불행의 출발점은 게으름******
잃지 말아야 하는건 부지런함**(근태, 복습, 주말,시간을 어떻게서든 내야 돼)
주말일정 전부다 취소시키고 주말을 안하면 못따라감.
공부량을 늘려가려면 주말 사소한 약속 다 제껴라.
감정낭비 X 사회적 위치에 올라가기전까지는.
집중을 방해하는 감정낭비의 요소를 제거하지않으면 공부에 집중이 안된다.
짧게는 6개월 딱 1년만 3-4년차 경력자되면 가라 스트레스해소로.
궤도에 오르기전까지는 그런것들은 나를 주저앉히는 시간낭비가 된다.
의욕만 갖고 되는게 아니다. 환경을 정비해야된다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
4교시
 
new키워드(역할) 

=> 객체 생성할 때 나옴
1. new 오른쪽 생성자명나옴 그생성자를 갖고있는 클래스 찾는 것
2. 메모리 공간에 올려서 객체화
3. 메모리에 올라간 생성자를 호출
4. 객체의 메위주를 리턴 

 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
객체참조 변수 없이 객체 생성과 동시에 속성변수나 메소드를 호출할수도 있다.
이럴경우 객체참조 변수가 없으므로 객체의 메모리 위치 주소값을 모르므로 속성변수나 메소드의 재호출이 불가능하다
 
호출방법.
1. new 클래스명().속성변수명
2.new ().메소드명()
1.

Xxx obj = new Xxx().getX();

int mmm = obj.getX();

이게 낫다. 
 
2.

int mmm = new Xxx().getX();

그 객체에 다시한번 접근하는 방법이 없다.
xxx의 메위주를 저장하지않고
바로 xxx의 메위주 안의 getX()호출한 그놈을 집어넣은거다
 
이후에 메위주를 속성변수를 호출할수있는 방법이 없다.
단한번만 할거면 이게 낫지만 좋은 방법은 아니다.
될수있으면 변수에 저장해라 고객마음이 어떻게 바뀔줄안다고
재사용성을 위해.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
 
 
Xxx obj = new Xxx();
 
Yyy obj = new Xxx();
yyy는부모  xxx는 자손.
 
obj.getM() ;
 
 
 
Xxx obj = new Xxx();

Yyy obj = new Xxx();

 
yyy가 부모라는 뜻
 
 
클래스명이 자료형이 될수있다 속성변수명이나 메서드명 앞에 나오면 자료형 이다. 
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
this 용법

 
this 내꺼.
내멤버임을 강조할때 내거하고 헷갈리는 남의 것이있다.
 
this.속성변수명

왜붙일까?
속성변수엔
속성변수와 매개변수(지역변수)가 이름이 같아서
 
this.메소드명(~)

메소드는 왜붙일까?
부모거랑 내거랑 같을 경우가 있다.
내거가 아닌경우가 있다.
부모랑 내거랑 헷갈리는경우가 있다.
(ex)나도 갤럭시20 엄마거도 갤럭시 20)
 
this(~)

(this.생성자도 있다)
 
this를 super로 바꾸면 부모꺼가 된다
super.부모메소드
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
 
속성변수와 메서드 선언 시 사용되는 자료형의 의미

 
변수의 자료형이 Object면 모든 클래스가 다 들어갈 수 있다.
ex) private Object xxx;

모든 클래스를 객체화해서 메위주를 집어넣을 수 있다.
 
접근지정자

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
6교시
 
 
 
 
한 자식의 부모가 두명이면 안된다 
두부모일때 두부모의 메소드가 같다면 누구껄 호출할 것인가.
그렇기 때문에 subclass는 2super 클래스를 가질 수 없다.
 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
7교시
 
 
